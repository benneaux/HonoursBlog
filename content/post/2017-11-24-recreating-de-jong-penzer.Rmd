---
title: Recreating De Jong & Penzer
author: Benjamin G. Moran
date: '2017-11-24'
slug: recreating-de-jong-penzer
categories:
  - Modelling
tags:
  - Flutracking
description: Here we'll attempt to recreate some of the output found in De Jong and Penzer's paper. Firstly, the level and state shock statistics.
---

In their paper _Diagnosing Shocks in Time Series_ De Jong and Penzer produce graphs of their $\tau^2$ statistic for the measurement and level shocks in the Nile (Cobb 1978) data (figure 3). Using the `MARSS` package in `R` I have been able to recreate the __Measurement__ and __Level__ shock statistics perfectly (I think).

Firstly, the model.

### MARSS Model for Nile Data

```{r}
library(MARSS)
dat = t(as.matrix(Nile))

# The model below produces the same results - and matches the example in MARSS package
# but I've made the values explicit to aid comprehension.

# mod.nile.2 = list(Z=matrix(1),  
#                   A=matrix(0),
#                   R=matrix("r"),
#                   B=matrix(1),
#                   U=matrix(0),
#                   Q=matrix("q"),
#                   x0=matrix("pi"))

mod.nile.2 = list(Z=matrix(1), 
                  A=matrix(0),
                  R=matrix(15099),
                  B=matrix(1),
                  U=matrix(0),
                  Q=matrix(1469),
                  x0=matrix(1120))
kem.2em = MARSS(dat, model=mod.nile.2, silent=FALSE) # inits

kem.2 = MARSS(dat, model=mod.nile.2,inits=kem.2em$par, method="BFGS") # model

resids.2a = residuals(kem.2) # store the residuals separately
```

This is simply a recreation of an example found in the MARSS user guide. The `kem.2em` is an `arima(1,1,0)` model specified in the original paper as being the best fitting, with the values for variance of system and measurement noise being supplied.^[Note: as I say in the comment code, MARSS can calculate the same values independently.] The `kem.2` object is the model object filtered by the fitted model; the residuals of this object will provide us with De Jong and Penzer's __state__ and __level__ shocks.


### Recreating the Graphs: State and Level shocks

Now, here are their graphs:

![](/Images/DJP/DJP_Figure3.jpeg)

and here are mine

#### Measurement Shocks -> Standardised Residuals [1,] (Squared)

```{r, echo = FALSE}
library(ggplot2)

df <- data.frame(Year = seq(1871,1970,1), resids = resids.2a$std.residuals[1,]^2)
ggplot(data = df, aes(y = resids, x = Year)) +
  geom_path() +
  theme_linedraw()

```

#### Level Shocks -> Standard Residuals [2,] (Squared)

```{r, echo = FALSE}
df <- data.frame(Year = seq(1871,1970,1), resids = resids.2a$std.residuals[2,]^2)
ggplot(data = df, aes(y = resids, x = Year)) +
  geom_path() +
  theme_linedraw()
```

Alhough it may be hard to judge the scaling, these are the same as far as I can tell without having access to their data.

## Test Statistic


```{r, echo = FALSE}
mod.nile.0 = list(
 Z=matrix(1), A=matrix(0), R=matrix("r"),
 B=matrix(1), U=matrix(0), Q=matrix(0),
 x0=matrix("a") )
dat = t(as.matrix(Nile))
 #Now we fit the model
 kem.0 = MARSS(dat, model=mod.nile.0)
resids.0=residuals(kem.0)$std.residuals

df <- data.frame(Year = seq(1871,1970,1), resids = resids.0[1,]^2)
ggplot(data = df, aes(y = resids, x = Year)) +
  geom_path() +
  theme_linedraw()

```


```{r}
mod.nile.1 = list(
 Z=matrix(1), A=matrix(0), R=matrix("r"),
 B=matrix(1), U=matrix("u"), Q=matrix(0),
 x0=matrix("a") )

kem.1 = MARSS(dat, model=mod.nile.1)
resids.1=residuals(kem.1)$std.residuals

df <- data.frame(Year = seq(1871,1970,1), resids = resids.1[1,]^2)
ggplot(data = df, aes(y = resids, x = Year)) +
  geom_path() +
  theme_linedraw()

```


```{r}
x = vector(mode = "numeric")
for (i in 1:100){
  x[i] = max(resids.2a$residuals[1,i],resids.2a$residuals[2,i])
}

df <- data.frame(Year = seq(1871,1970,1), resids = x^2)
ggplot(data = df, aes(y = resids, x = Year)) +
  geom_path() +
  theme_linedraw()
```

```{r, eval = FALSE}
kf <- MARSSkfas(kem.2, return.kfas.model = TRUE)
# plot(ts(c(dat)))
# lines(ts(c(kem.2$states)))
# x = c(dat)-c(kem.2$states)
# plot(ts(c(kf$xtT)))
plot(ts(c(dat)))
lines(ts(c(kf$xtt)))
lines(ts(c(kf$xtT)))

x = ts(c(kf$Innov)/c(kf$Sigma))
plot(ts(c(kf$Innov)))
```

